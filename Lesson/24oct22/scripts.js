// Перебор: forEach
// Метод arr.forEach позволяет запускать функцию для каждого элемента массива

// Его синтаксис:
// arr.forEach(
// 		function(item, index, array) {
// 	  // ... делать что-то с item
// 		}
// );



// Например, этот код выведет на экран каждый элемент массива:
// Вызов console.log для каждого элемента

// ["Bilbo", "Gandalf", "Nazgul"].forEach(
// 	(item, index, array) => {
// 	  console.log(`${item} имеет позицию ${index} в ${array}`);
// 	}
// );










// includes - Поиск в массиве
// arr.includes(item, from) – ищет item, начиная с индекса from, 
// и возвращает true, если поиск успешен.

// let arr = [1, 0, false];
// console.log( arr.includes(1) ); // true

// const arr = [NaN];
// console.log( arr.includes(NaN) );// true (верно)











// углубленный поиск в массиве find
// Представьте, что у нас есть массив массивов. 
// Как нам найти вложенный массив с определённым условием?

// Здесь пригодится метод arr.find.
// Его синтаксис таков:


// let result = arr.find(
// 		function(item, index, array) {
// 	  // если true - возвращается текущий элемент и перебор прерывается
// 	  // если все итерации оказались ложными, возвращается undefined
// 	}
// );


// Функция вызывается по очереди для каждого элемента массива:
// item – очередной элемент.
// index – его индекс.
// array – сам массив.
// Если функция возвращает true, поиск прерывается и возвращается item. 
// Если ничего не найдено, возвращается undefined.

// Например, у нас есть массив c массивами пользователей, 
// каждый из которых имеет первым элементом фамилию, вторым имя. 
// Попробуем найти того, кто с фамилией Агранова

// let users = [
//   ['Иванов', "Вася"],
//   ['Петров', "Петя"],
//   ['Агранова', "Соня"],
// ];


// let user = users.find(
// 	(item, i ) => i == 1 // if true return item
// )[0]; // стрелочный

// let user2 = users.find(
// 	function(item) {
// 		return item[0] == 'Петров' // if true return item
// 	} // декларативный
// );


// console.log(user); // ['Агранова', "Соня"]
// console.log(user2);







// отфильтровать массив - filter
// Синтаксис этого метода схож с find, но 
// filter возвращает массив из всех подходящих элементов

// let results = arr.filter( // results = [...]
// 	function(item, index, array) {
//   // если true - элемент добавляется к результату, и перебор продолжается
//   // возвращается пустой массив в случае, если ничего не найдено
// 	}
// );


// let users = [
//   ['Иванов', "Вася"],
//   ['Агранов', "Петя"],
//   ['Агранова', "Маша"],
// ];

// let checkFunc = function(item,i,array) {
// 	return item[0][0] === 'А'
// }

// let someUsers = users.filter(
// 	item => item[0][0] === 'А'
// );

// let someUsers2 = users.filter( // соберет в массив items
// 	checkFunc // описание функции, или анонимная функция прямо здесь
// ); // аргументом является callback function

// console.log(someUsers);









// Преобразование массива
// map
// Метод arr.map является одним из наиболее полезных и часто используемых.
// Он вызывает функцию для каждого элемента массива 
// и возвращает массив результатов выполнения этой функции.

// Синтаксис:
// let result = arr.map(
// 	function(item, index, array) {
//   	// возвращается новое значение вместо элемента
// 	}
// );
// Например, здесь мы преобразуем каждый элемент в его длину:


// let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(
// 	item => item.length
// );


// let lengths2 = ["Bilbo", "Gandalf", "Nazgul"].map(
// 	function(item) {
// 		if (item === "Gandalf") {
// 			return item.toUpperCase()
// 		}
// 		return item
		
// 	}
// );
// console.log(lengths2)





// let arr = ["Bilbo", "Gandalf", "Nazgul"];

// let changeNasgulToHobbit = arr.map( // ["Bilbo", "Gandalf", "Hobbit"]
// 	function(item) {
// 		if (item === "Nazgul") {
// 			return "Hobbit"
// 		}
// 		return item
// 	}
// )

// console.log(arrMapping)



// console.log(lengths); // 5,7,6






// let numbers = [5,4,7,12,78,457,2,5];
// let numbersFiveToSquere = numbers.map(
// 	item => item === 5 ? item*item : item
// )
// console.log(numbersFiveToSquere)







// split и join - разбивка и соединение строк в массивы

// let names = 'Вася, Петя, Маша';

// let arr = names.split(', ');

// for (let name of arr) {
//   console.log( `Сообщение получат: ${name}.` ); // Сообщение получат: Вася (и другие имена)
// }


// У метода split есть необязательный второй числовой аргумент 
// – ограничение на количество элементов в массиве. 
// Если их больше, чем указано, то остаток массива будет отброшен. 
// На практике это редко используется:

// let arr = 'Вася, Петя, Маша, Саша'.split(', ', 2);
// console.log(arr); // Вася, Петя




// Разбивка по буквам
// Вызов split(s) с пустым аргументом s разбил бы строку на массив букв:
// let str = "тест";
// console.log( str.split('') ); // т,е,с,т


// Вызов arr.join(glue) делает в точности противоположное split. 
// Он создаёт строку из элементов arr, вставляя glue между ними.

// Например:
// let arr = ['Вася', 'Петя', 'Маша'];
// let str = arr.join(';'); // объединить массив в строку через ; 

// console.log( str ); // Вася;Петя;Маша














// Итого
// Шпаргалка по методам массива:

// Для добавления/удаления элементов:

// push (...items) – добавляет элементы в конец,
// pop() – извлекает элемент с конца,
// shift() – извлекает элемент с начала,
// unshift(...items) – добавляет элементы в начало.
// splice(pos, deleteCount, ...items) – начиная с индекса pos, удаляет deleteCount элементов и вставляет items.
// slice(start, end) – создаёт новый массив, копируя в него элементы с позиции start до end (не включая end).
// concat(...items) – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items. Если какой-то из items является массивом, тогда берутся его элементы.

// Для поиска среди элементов:
// indexOf/lastIndexOf(item, pos) – ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено.
// includes(value) – возвращает true, если в массиве имеется элемент value, в противном случае false.
// find/filter(func) – фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых через функцию возвращается true.
// findIndex похож на find, но возвращает индекс вместо значения.

// Для перебора элементов:
// forEach(func) – вызывает func для каждого элемента. Ничего не возвращает.

// Для преобразования массива:
// map(func) – создаёт новый массив из результатов вызова func для каждого элемента.
// sort(func) – сортирует массив «на месте», а потом возвращает его.
// reverse() – «на месте» меняет порядок следования элементов на противоположный и возвращает изменённый массив.
// split/join – преобразует строку в массив и обратно.
// reduce(func, initial) – вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая промежуточный результат между вызовами.



// Дополнительно:
// Array.isArray(arrBlablabla); // проверяет, является ли arr массивом.



// Главное это сейчас 
// find/filter 
// forEach/map





// Последнее - синтаксический сахар
// деструктуризация массива


// синтаксис для массива:

let catArray = ['Кошачий корм', 'www.corm.ua', 600, 'дополнительные данные', 'не всегда нужные данные']

let [header, link, price, ...restData] = catArray;

console.log(header);
console.log(link);
console.log(price);
console.log(restData);
// Первый элемент отправляется в item1; 
// второй отправляется в item2, 
// все остальные элементы попадают в массив rest.

// Можно извлекать данные из вложенных объектов и массивов, 
// для этого левая сторона должна иметь ту же структуру, что и правая.


// Пример деструктуризации массива:

// // у нас есть массив с именем и фамилией

// let arr = ["Ilya", "Kantor"]
// let [firstName, surname] = arr;

// console.log(firstName)
// console.log(surname)
// // деструктурирующее присваивание
// записывает firstName=arr[0], surname=arr[1]


// console.log(firstName); // Ilya
// console.log(surname);  // Kantor




// оператор rest - Остаточные параметры «…»
// Если мы хотим не просто получить первые значения, 
// но и собрать все остальные, то мы можем добавить ещё один параметр, 
// который получает остальные значения, используя оператор 
// «остаточные параметры» – троеточие ("..."):

// let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

// console.log(name1); // Julius
// console.log(name2); // Caesar
// console.log(rest); // ["Consul", "of the Roman Republic"]

// // Обратите внимание, что `rest` является массивом.
// console.log(rest[0]); // Consul
// console.log(rest[1]); // of the Roman Republic
// console.log(rest.length); // 2










// Фильтрация по диапазону

// Напишите функцию filterRange(arr, a, b), которая принимает массив arr,
// ищет элементы со значениями больше или равными a и меньше или равными b и возвращает результат в виде массива.

// Функция должна возвращать новый массив и не изменять исходный.

// Например:
// let arr = [5, 3, 8, 1];
// let filtered = filterRange(arr, 1, 4);

// console.log( filtered ); // 3,1 (совпадающие значения)
// console.log( arr ); // 5,3,8,1 (без изменений)












// Напишите функцию filterRangeInPlace(arr, a, b), 
// которая принимает массив arr и удаляет из него все значения кроме тех, 
// которые находятся между a и b. То есть, проверка имеет вид a ≤ arr[i] ≤ b.

// Функция должна изменять принимаемый массив и ничего не возвращать.

// Например:
// let arr = [5, 3, 8, 1];
// filterRangeInPlace(arr, 1, 4); // удалены числа вне диапазона 1..4
// alert( arr ); // [3, 1]