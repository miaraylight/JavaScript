// Задача из домашки

// let someArray = [1, 4, 3, 2, 5, 6, 7] // arr.length = 7

// function filterRangeInPlace(arr, a,b) { // arr мы изменяем исходный
//     for (let i = 0; i < arr.length; i++) { // 1. перебор массива
//         if (arr[i] < a || arr[i] > b) { // условие выхода из диапазона
//             arr.splice(i,1);
//             i--;
//         }
//     }
// }


// console.log(someArray);
// filterRangeInPlace(someArray, 1,4);
// console.log(someArray);




// let someArray = ["Вввв","Ffff"];
// let someArray2 = [...someArray];
// console.log(
// 	...someArray
// )

// function someFun(
// 	importantArg1,
// 	importantArg2,
// 	...rest
// 	) {
// 	console.log(importantArg1)
// 	console.log(importantArg2)

// 	if (importantArg2 === 35) {
// 		console.log(rest)
// 		rest.forEach(
// 			item => console.log(item)
// 		)
// 	}
// }

// someFun('Tjaša', 35, 'fdfd')


// const [name, age, ...rest] = ['Tjaša', 35, 'fdfd', 4545, false];
// console.log( name, age );
// console.log( rest );









// Пустой объект («пустой ящик») можно создать, 
// используя один из двух вариантов синтаксиса:

// let user = new Object(); // синтаксис "конструктор объекта"
// let user = {}; // синтаксис "литерал объекта"


// Литералы и свойства
// let user = {     // объект
//   name: "John",  // под ключом "name" хранится значение "John"
//   age: 30,     // под ключом "age" хранится значение 30
// };

// // // // получаем значение из свойства объекта:
// console.log( user.name ); // John
// console.log( user.age ); // 30
// // через точку по ключу



// console.log( user ); // исходный объект {name: 'John', age: 30}
// user.isAdmin = true; // добавим свойство с логическим значением
// console.log( user ); // c новым свойством isAdmin {name: 'John', age: 30, isAdmin: true}
// delete user.age; // удаление свойства
// console.log( user ); // без свойства age {name: 'John', isAdmin: true}







// Объект, объявленный как константа, может быть изменён
// потому что меняется не сам объект, а его свойство
// const user = {
//   name: "John"
// };
// user.name = "Pete"; // (*)
// console.log(user.name); // Pete

// console.log(user["name"]); // Pete - можно обратится и не через точку



// const user = {
//   name: "John",
//   age: 25
// };
// let userKey = "age";
// console.log(user)

// console.log( user[userKey] ); // Pete - и через переменную соотвественно
// console.log(user)
// user = { // а вот это уже вызовет ошибку
//   age: 25
// }













// // так же к ключам тоже можно задавать через квадратные скобки
// let fruit = "apple";

// let bag = {
//   [fruit]: 5, // имя свойства будет взято из переменной fruit
// };

// console.log(bag)
// console.log( bag.apple ); // 5
// console.log( bag["apple"] ); // 5
// console.log( bag[fruit] ); // 5


// соотвественно, ключ может вычислятся динамически
// но используется это не частно, но тем не менее
// let fruit = 'apple';
// let bag = {
//   [fruit + 'Computers']: 5 // bag.appleComputers = 5
// };

// Квадратные скобки дают намного больше возможностей, 
// чем запись через точку. 
// Они позволяют использовать любые имена свойств и переменные, 
// хотя и требуют более громоздких конструкций кода.

// Подведём итог: в большинстве случаев, 
// когда имена свойств известны и просты, 
// используется запись через точку. 
// Если же нам нужно что-то более сложное, 
// то мы используем квадратные скобки.


// Свойство из переменной
// В реальном коде часто нам необходимо использовать существующие переменные 
// как значения для свойств с тем же именем.

// function makeUser(name, age) {//"John", 30
//   return {
//     name: name,//"John"
//     age: age//30
//   };
// }

// let user = makeUser("John", 30); // {name: "John", age: 30}
// let user2 = makeUser("Alex", 45); // {name: "Alex", age: 45}
// let user3 = makeUser("Vlad", 31); // {name: "Vlad", age: 31}

// console.log(user3);

// В примере выше название свойств name и age совпадают с названиями переменных, 
// которые мы подставляем в качестве значений этих свойств. 
// Такой подход настолько распространён, 
// что существуют специальные короткие свойства для упрощения этой записи.

// Вместо name:name мы можем написать просто name:

// function makeUser(name, age) {
//   return {
//     name, // то же самое, что и name: name
//     age   // то же самое, что и age: age
//   };
// }


// Ограничения на имена свойств
// Как мы уже знаем, имя переменной не может совпадать 
// с зарезервированными словами, такими как «for», «let», «return» и т.д.
// Но для свойств объекта такого ограничения нет:

// эти имена свойств допустимы
// let obj = {
//   for: 1,
//   let: 2,
//   return: 3
// };

// console.log( obj.for + obj.let + obj.return );  // 6














// обращение к несуществующему свойству
// let user = {
// 	age: 25
// };
// console.log( user.noSuchProperty === undefined ); // true значит свойства нет
// console.log(user)









// Проверка существования свойства, оператор «in»
// для проверки существования свойства в объекте.

// Синтаксис оператора:
// "key" in object

// let user = { 
// 	name: "John", 
// 	age: 30 
// };

// let userKey = "age";
// console.log( userKey in user ); // true, user.age существует
// console.log( "blabla" in user ); // false, user.blabla не существует


// let user = { age: 30 };
// let key = "age";
// console.log( key in user ); // true, имя свойства было взято из переменной key


// Для чего вообще нужен оператор in? Разве недостаточно сравнения с undefined?
// В большинстве случаев прекрасно сработает сравнение с undefined. 
// Но есть особый случай, когда оно не подходит, и нужно использовать "in".
// Это когда свойство существует, но содержит значение undefined:
// let obj = {
//   tel: 656565,
//   email: "babbaba@gmail.com",
//   photo: null
// };

// obj.test//undefined
// obj.photo//null

// console.log( obj.test ); //  выведет undefined, значит свойство не существует?
// console.log( "test" in obj ); // true, свойство существует!










// Перебор объекта
// Цикл "for..in"
// Для перебора всех свойств объекта используется цикл for..in. 
// Этот цикл отличается от изученного ранее цикла for(;;).

// Синтаксис:
// for (key in object) {
//   // тело цикла выполняется для каждого свойства объекта
// }




// let user = {
//   name: "John",
//   age: 30,
//   isAdmin: true
// };

// for (let someKey in user) { // пока есть ключи в объекте
//   // ключи
//   console.log( someKey );  // "name", "age", "isAdmin"
//   // значения ключей
//   console.log( user[someKey] ); // John, 30, true
// }







// Все конструкции «for» позволяют нам объявлять 
// переменную внутри цикла, как, например, let someKey здесь.

// Кроме того, мы могли бы использовать другое имя переменной. 
// Например, часто используется вариант "for (let prop in obj)".













// Итого
// Объекты – это ассоциативные массивы с рядом дополнительных возможностей.

// Они хранят свойства (пары ключ-значение), где:

// Ключи свойств должны быть строками.
// Значения могут быть любого типа.
// Чтобы получить доступ к свойству, мы можем использовать:

// Запись через точку: obj.property.
// Квадратные скобки obj["property"]. 
// Квадратные скобки позволяют взять ключ из переменной, например, obj[varWithKey].

// Дополнительные операторы:
// Удаление свойства: delete obj.prop.
// Проверка существования свойства: "key" in obj.
// Перебор свойств объекта: цикл for for (let key in obj).
// То, что мы изучали в этой главе, называется 
// «простым объектом» («plain object») или просто Object.

// В JavaScript есть много других типов объектов:

// Array для хранения упорядоченных коллекций данных,
// Date для хранения информации о дате и времени,
// Error для хранения информации об ошибке.
// … и так далее.









// Задачи
// 1)
// Напишите код, выполнив задание из каждого пункта отдельной строкой:

// Создайте пустой объект user.
// Добавьте свойство name со значением John.
// Добавьте свойство surname со значением Smith.
// Измените значение свойства name на Pete.
// Удалите свойство name из объекта.






// 2)
// Проверка на пустоту
// Напишите функцию isEmpty(obj), которая возвращает true, 
// если у объекта нет свойств, иначе false.

// Должно работать так:

// let schedule = {};
// console.log( isEmpty(schedule) ); // true
// schedule["8:30"] = "get up";
// console.log( isEmpty(schedule) ); // false





// 3)
// Объекты-константы
// Можно ли изменить объект, объявленный с помощью const? Как вы думаете?

// const user = {
//   name: "John"
// };

// // // это будет работать?
// user.name = "Pete";


























// Копирование объектов и ссылки


// Одно из фундаментальных отличий объектов от примитивов заключается в том, 
// что объекты хранятся и копируются «по ссылке»
// Это легко понять, если мы немного заглянем под капот того, 
// что происходит, когда мы копируем значение.

// Давайте начнём с примитива, такого как строка.
// Здесь мы помещаем копию message во phrase:
// let message = "Привет!";
// let phrase = message;
// В результате мы имеем две независимые переменные, каждая из которых хранит строку "Привет!".


// Объекты ведут себя иначе.
// Переменная, присвоенная объекту, хранит не сам объект, 
// а его «адрес в памяти» – другими словами, «ссылку» на него.

// При копировании переменной объекта копируется ссылка, но сам объект не дублируется.

// let user = { name: "John" };
// let admin = user; // копируется ссылка
// Теперь у нас есть две переменные, 
// каждая из которых содержит ссылку на один и тот же объект


// Мы можем использовать любую переменную для доступа к объекту и изменения его содержимого:
// let user = { name: 'John' };
// let admin = user;
// admin.name = 'Pete'; // изменено по ссылке из переменной "admin"
// console.log(user.name); // 'Pete', изменения видны по ссылке из переменной "user"









// Сравнение по ссылке
// Два объекта равны только в том случае, если это один и тот же объект.

// Например, здесь a и b ссылаются на один и тот же объект, поэтому они равны:
// let a = {};
// let b = a; // копирование по ссылке
// console.log( a == b ); // true, обе переменные ссылаются на один и тот же объект
// console.log( a === b ); // true


// И здесь два независимых объекта не равны, даже если они выглядят одинаково (оба пусты):
// let a = {};
// let b = {}; // два независимых объекта
// console.log( a == b ); // false









// Клонирование и объединение, Object.assign

// клонирование перебором
// let user = {
//   name: "John",
//   age: 30
// };

// let clone = {}; // новый пустой объект

// // давайте скопируем все свойства user в него
// for (let key in user) { // name, age
//   clone[key] = user[key];
//   //1-clone.name = "John"
//   //2-clone.age = 30
// }
// console.log(clone)
// console.log(clone === user)



// console.log(clone)
// console.log(user)
// // теперь clone это полностью независимый объект с тем же содержимым
// console.log( user.name ); // все ещё John в первоначальном объекте

// let user = {};
// user.name = 'John';
// user.surname = 'Smith';
// console.log(user);
// user.name = 'Pete';
// console.log(user);
// delete user.name;
// console.log(user);

// function isEmpty(obj) {
//     for (const key in obj) {
//         console.log(key);
//             return false;
//     }
//     return true;
// }

// let helpers = {
//     isEmpty: obj => {
//         for (const key in obj) {
//             console.log(key);
//                 return false;
//         }
//         return true;
//     }
// }

// console.log(helpers.isEmpty({}));

